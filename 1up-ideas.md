# 1up-ideas

### 2024-07-26 05:56 - tuenti1

it occured to me that I think it'd be really fun to just go to russia and make a social network for starters. getting many2many communication (m2mc) going really quickly and efficiently in a fully distributed code/data network. that'll be the start of what we need for the next project, where we'll need to adjust the communication and function of many n[uo][bd]s in 3d, will be required -- so the best application/implementation I can think of (with real intelligent beings) is a social network. so we could just start with a social network and then I'll work my way toward what I want.
I have many other "one more" or 1up ideas in addition to this one that can easily be seen as "next logical step" (on the way toward what I want). [06:00][I'm aware that all such ideas automatically put me into the "2nd-ray" category -- but if they're crowd-pleasers, then I'm all for it. I find the subject quite interesting and a pretty logical step in the direction of what I want -- so seems pretty good. I'll update soon (or make a new folder)]

### 2024-07-26 06:09 - afinati2

same sorta deal as tuenti1: I'll do the same idea but the way that I'd love to do it. having to make this project work will require a whole lot of autonomous code structures that just go and keep things up to date in responce to other data/code structures (the network runs autonomously on many distributed nodes). dynamic data/code structwures will be important for monitoring and "hooking" the system to respond dynamically (all things are functions -- even the constants are just functions which return the constant (since the fn address is the same a comparison to the object reference is enough to ensure constants compare correctly (unless it's overridden the compare function (ala lua)))). it's interesting to note that each afiniti group will have its own code for maintaining itself. at first it'll be the default structure, but any updates to the code, the private key (to update the code) will be the hash of itself -- meaning that anyone can change the code (we'll have a private network, to mitigate difficulty, and need to worry about the access functions -- and one day we'll need to have safety/assurance functions to keep the thing running properly (like an autorevert updates to fn code if it doesn't pass some list of tests -- which again cAn bwe overwritten by anyone (but the update function has to pass -- meaing that the object itself determines its value -- so a true function cannot be overwritten by something else because the onupdate function will ensure that the result/test of the function returns true (and is simpler, and maybe a few more security/assurances it ensures)) -- so the system will divide into super-maintaining parts of each larger structure (like 2+ cores all doing simultaneous jobs) just by boxing every function in a more complicated function, and building a robust system for that will ensure that the system *does what it says it does* -- so for example, if the function is designed to double something; if someone changes the code to something that doesn't pass the test, then it just rewrites the code with the last latest version. there's also between each node (cause they're physical machines) there's an access layer to ensure others aren't just sapping resources like a hog. therefore the node can then limit access the code/data -- and obviously code has to access data it references, but each function also has a box with error cases as well, just in case data isn't available)). all this is important, because the symbolic relations that we use to find our afinati21another in human interactions, we will not just assume that they all relate exactly the same,-- which is complex issue which we will tackle with an "afiniti-function" (af) will be unique to each concept pair/triplet (anyth[io]ng that has multiple match branchs) -- cause not every concept relates one to another with an equal linear/defined curve. (I'm going to ignore the whole ideology bit becazuse that's an emergent feature from the way it's programmed (everything is number/string/code/data))
in order for such a thing to be possible, all the code itself needs to be a function, which is a function -- and each one of those function/code objects lives as a function within a large (1024b?) address space where a node can define itself as owner of that space (which can be overwritten by the private key of the node resolution -- ensuring that a system to organise/lease the space is implemented (all-open concepts are a later tthing)) -- so everything is just an object reference -- and that object can be a enum/number/string/data/code (prolly 4 types of things (plus the constants/enums), then later code will need to sometimes have a stack frame, just box code/data with the correct input/output functions (as a struct), cause everything will want to be boxed many times so that code (types and segments) can be anything). everything gets a box, because we're going to think in terms of hardware, where going to the correct unboxing logic/circuit is just a pattern recognition (instant) on the box (cause each function get implemented automatically in hardware (coming soon)).
anyway all that eventually resolves into a symbolic system of how ideas are logically accessed through code, each box/struct a bit more of a higher level implementation than any of its lower parts. all implementations are just functions. there are also renderers, which convert the output/results of various function calls into something visual/audible/tangible/etc.
