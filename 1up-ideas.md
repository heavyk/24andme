# 1up-ideas

### 2024-07-26 05:56 - tuenti1

it occured to me that I think it'd be really fun to just go to russia and make a social network for starters. getting many2many communication (m2mc) going really quickly and efficiently in a fully distributed code/data network. that'll be the start of what we need for the next project, where we'll need to adjust the communication and function of many n[uo][bd]s in 3d, will be required -- so the best application/implementation I can think of (with real intelligent beings) is a social network. so we could just start with a social network and then I'll work my way toward what I want.
I have many other "one more" or 1up ideas in addition to this one that can easily be seen as "next logical step" (on the way toward what I want). [06:00][I'm aware that all such ideas automatically put me into the "2nd-ray" category -- but if they're crowd-pleasers, then I'm all for it. I find the subject quite interesting and a pretty logical step in the direction of what I want -- so seems pretty good. I'll update soon (or make a new folder)]

### 2024-07-26 06:09 - afinati2

same sorta deal as tuenti1: I'll do the same idea but the way that I'd love to do it. having to make this project work will require a whole lot of autonomous code structures that just go and keep things up to date in responce to other data/code structures (the network runs autonomously on many distributed nodes). dynamic data/code structwures will be important for monitoring and "hooking" the system to respond dynamically (all things are functions -- even the constants are just functions which return the constant (since the fn address is the same a comparison to the object reference is enough to ensure constants compare correctly (unless it's overridden the compare function (ala lua)))). it's interesting to note that each afiniti group will have its own code for maintaining itself. at first it'll be the default structure, but any updates to the code, the private key (to update the code) will be the hash of itself -- meaning that anyone can change the code (we'll have a private network, to mitigate difficulty, and need to worry about the access functions -- and one day we'll need to have safety/assurance functions to keep the thing running properly (like an autorevert updates to fn code if it doesn't pass some list of tests -- which again cAn bwe overwritten by anyone (but the update function has to pass -- meaing that the object itself determines its value -- so a true function cannot be overwritten by something else because the onupdate function will ensure that the result/test of the function returns true (and is simpler, and maybe a few more security/assurances it ensures)) -- so the system will divide into super-maintaining parts of each larger structure (like 2+ cores all doing simultaneous jobs) just by boxing every function in a more complicated function, and building a robust system for that will ensure that the system *does what it says it does* -- so for example, if the function is designed to double something; if someone changes the code to something that doesn't pass the test, then it just rewrites the code with the last latest version. there's also between each node (cause they're physical machines) there's an access layer to ensure others aren't just sapping resources like a hog. therefore the node can then limit access the code/data -- and obviously code has to access data it references, but each function also has a box with error cases as well, just in case data isn't available)). all this is important, because the symbolic relations that we use to find our afinati21another in human interactions, we will not just assume that they all relate exactly the same,-- which is complex issue which we will tackle with an "afiniti-function" (af) will be unique to each concept pair/triplet (anyth[io]ng that has multiple match branchs) -- cause not every concept relates one to another with an equal linear/defined curve. (I'm going to ignore the whole ideology bit becazuse that's an emergent feature from the way it's programmed (everything is number/string/code/data))
in order for such a thing to be possible, all the code itself needs to be a function, which is a function -- and each one of those function/code objects lives as a function within a large (1024b?) address space where a node can define itself as owner of that space (which can be overwritten by the private key of the node resolution -- ensuring that a system to organise/lease the space is implemented (all-open concepts are a later tthing)) -- so everything is just an object reference -- and that object can be a enum/number/string/data/code (prolly 4 types of things (plus the constants/enums), then later code will need to sometimes have a stack frame, just box code/data with the correct input/output functions (as a struct), cause everything will want to be boxed many times so that code (types and segments) can be anything). everything gets a box, because we're going to think in terms of hardware, where going to the correct unboxing logic/circuit is just a pattern recognition (instant) on the box (cause each function get implemented automatically in hardware (coming soon)).
anyway all that eventually resolves into a symbolic system of how ideas are logically accessed through code, each box/struct a bit more of a higher level implementation than any of its lower parts. all implementations are just functions. there are also renderers, which convert the output/results of various function calls into something visual/audible/tangible/etc.

#### 2024-07-26 07:16 - matching an array anything(s)

the input to each function (its parameters) can be anything. each parameter is named, and can be a box of anything. therefore each parameter is an anythong (the receiver of anything). if the parameter was not specified, it is "undefined". undefined itself is not a value, but a check that anythong has to see if something's in it. probably "full" or "filled/loaded/available" is a better name for the test actually (not sure gonna leave that one up to the naming committee).
	which btw, I have to say -- why not just always pick the worst possible (most crass name to describe it's function graphically -- like an omnidirectional receiver might be called a "bukakee" (its spelling should be standarized too) -- that way the name churn will be rapid, and hilarious to look back on a few decades into the future). just always pick the name for the function that's most vivid -- until it becomes something wanted/awesome.
so now each function essentially has an automatic pattern match on all of its arguments, which match (un)defined argument tuples(?). if the pattern matches (eg. `{num:1,zero:"0",thing:undefined,data:[[{someting: "else"}]}` which resolves to `if #num is 1 and #zero is "0" and #thing isnt defined and #data is array and #data.*.something is "else"`) the inputs to the call resolve to a function which matches each pattern. intentionally these will be done in parallel and call the function that's mached -- which the function itself is referred to by name ("gimme-one-ting-something-else", which is just a fn-box reference to a function which passes its own tests to ensure it does what it says it does). I'd like to include conditionals on the matches as well (each match-condition is itself a function) -- and actually, one thing that strongly inspired me is a thing in lua that is for matching strings (I totally can't remember its name), but I want to be able to do offset calculations pointing into a buffer which can also reference other positions in that buffer (string matching code) (each function will have various implementations brokered out by the function as it figures out more valid implementations of itself (these also count toward security the function does what it says it does) which will have a different implementation for different envirments/conditions/parameters because each function symbol is itself a function which returns that symbol, and pattern matched sequences of those function symbols patterns, then implement that pattern which do things (ie, if A then B: if,then,A,B is a function that resolves to "if-statement" function, which performs the conditional operation. each ast token is itself a function)). [I need to stop]
