# 1up-ideas

### 2024-07-26 05:56 - tuenti1

it occured to me that I think it'd be really fun to just go to russia and make a social network for starters. getting many2many communication (m2mc) going really quickly and efficiently in a fully distributed code/data network. that'll be the start of what we need for the next project, where we'll need to adjust the communication and function of many n[uo][bd]s in 3d, will be required -- so the best application/implementation I can think of (with real intelligent beings) is a social network. so we could just start with a social network and then I'll work my way toward what I want.
I have many other "one more" or 1up ideas in addition to this one that can easily be seen as "next logical step" (on the way toward what I want). [06:00][I'm aware that all such ideas automatically put me into the "2nd-ray" category -- but if they're crowd-pleasers, then I'm all for it. I find the subject quite interesting and a pretty logical step in the direction of what I want -- so seems pretty good. I'll update soon (or make a new folder)]

### 2024-07-26 06:09 - afinati1

same sorta deal as tuenti1: I'll do the same idea but the way that I'd love to do it. having to make this project work will require a whole lot of autonomous code structures that just go and keep things up to date in responce to other data structures. this will be important for monitoring and "hooking" the system with dynamic code structures (all things are functions). it's interesting to note that each afiniti group will have its own code for maintaining itself. at first it'll be the default structure, but any updates to the code, the private key (to update the code) will be the hash of itself -- meaning that anyone can change the code (we'll have a private network, to mitigate difficulty, and need to worry about the access functions -- and one day we'll need to have safety/assurance functions to keep the thing running properly (like an autorevert if it doesn't pass the test -- which again cAn bwe overwritten by anyone -- so the system will divide into super-maintaining parts of the larger structure (like 2+ cores all doing simultaneous jobs) ensuring the system does what it says it does -- so for example, if the function is designed to double something; if someone changes the code to something that doesn't pass the test, then it just rewrites the code with the latest version -- then an access layer of who can access the node where that code/data lives -- obviously code has to access data it references, but not always the case)). human interactions, and how they relate, is equally complex, and so the "afiniti-function" (af) will be unique to each concept pair -- cause not every thing relates with an equal linear/defined curve.
in order for such a thing to be possible, all the code itself needs to be a function, which is a function -- and each one of those function/code objects lives as a function within a large (1024b?) address space where a node can define itself as owner of that space (which can be overwritten by the private key of the node resolution -- ensuring that a system to organise/lease the space is implemented (all-open concepts are a later tthing)) -- so everything is just an object reference -- and that object can be a enum/number/string/data/code (prolly 4 types of things (plus the constants/enums), then later code will need to sometimes have a stack frame, just box code/data with the correct input/output functions (as a struct), cause everything will want to be boxed many times so that code (types and segments) can be anything). everything gets a box, because we're going to think in terms of hardware, where going to the correct unboxing logic/circuit is just a pattern recognition (instant) on the box (cause each function get implemented automatically in hardware (coming soon)).
anyway all that eventually resolves into a symbolic system of how ideas are logically accessed through code, each box/struct a bit more of a higher level implementation than any of its lower parts. all implementations are just functions. there are also renderers, which convert the output/results of various function calls into something visual/audible/tangible/etc.
